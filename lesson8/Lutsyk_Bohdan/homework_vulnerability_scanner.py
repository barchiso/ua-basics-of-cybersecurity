"""Сканер вразливостей встановлених додатків."""

import logging
import random
import re
import subprocess
import sys
import time
from typing import Dict, Iterable, List, Optional

import pandas as pd
import requests


# ==================== CONFIG ====================
INSTALLED_APPS_FILE = 'installed_apps.txt'
NVD_API_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0'
HEADERS = {"User-Agent": "Mozilla/5.0 (compatible; SecurityScanner/1.1)"}

FALLBACK_APPS = (
    'Firefox',
    'Chrome',
    'VLC',
    '7-Zip',
    'Notepad++'
)
APPS_COUNT = 5

CVSS_LIMIT_CRITICAL = 9.0
CVSS_LIMIT_HIGH = 7.0
CVSS_LIMIT_MEDIUM = 4.0
CVSS_MIN_VULNERABLE = 7.0

RATE_LIMIT_DELAY = 6
MAX_RETRIES = 20
REQUEST_TIMEOUT = 30
RESULTS_PER_PAGE = 3

SEPARATOR_LENGTH = 40
SEPARATOR = '=' * SEPARATOR_LENGTH

CSV_FILENAME = 'my_vulnerabilities.csv'


# ==================== LOGGING ====================

LOG_FORMAT = '%(asctime)s [%(levelname)s] %(message)s'
LOG_DATEFMT = '%Y-%m-%d %H:%M:%S'

logging.basicConfig(
    level=logging.INFO,
    format=LOG_FORMAT,
    datefmt=LOG_DATEFMT,
)

LOGGER = logging.getLogger(__name__)


def log_info(message: str) -> None:
    """Логування інформаційного повідомлення."""
    LOGGER.info(message)


def log_section(title: str) -> None:
    """Логування секції."""
    log_info(SEPARATOR)
    log_info(title)
    log_info(SEPARATOR)


# ==================== APPS ====================

def run_get_installed_apps() -> None:
    """Виконання скрипту збору встановлених додатків."""
    try:
        subprocess.run(
            [sys.executable, 'get_installed_apps.py'],
            check=True,
        )
    except subprocess.CalledProcessError as error:
        LOGGER.warning(
            'Cannot run get_installed_apps.py: %s',
            error,
        )


def read_installed_apps() -> List[str]:
    """Читання списку встановлених додатків з файлу."""
    try:
        with open(INSTALLED_APPS_FILE, encoding='utf-8') as file_handler:
            apps = [
                line.strip()
                for line in file_handler
                if line.strip()
            ]
        return apps or list(FALLBACK_APPS)
    except FileNotFoundError:
        return list(FALLBACK_APPS)


def choose_random_apps(apps: Iterable[str], count: int) -> List[str]:
    """Вибір випадкових додатків зі списку."""
    unique_apps = sorted(set(apps))
    limit = min(count, len(unique_apps))
    return random.sample(unique_apps, limit)


def normalize_app_name(app_name: str) -> str:
    """Нормалізація назви додатку для пошуку вразливостей."""
    # 1. Видалення дужок та вмісту
    name = re.sub(r'\(.*?\)', '', app_name)

    # 2. Видалення архітектури
    name = re.sub(r'\b(x64|x86|64-bit|32-bit)\b',
                  '', name, flags=re.IGNORECASE)

    # 3. Видалення всього після " - "
    name = re.sub(r'\s+-\s+.*$', '', name)

    # 4. Python: прибрати версію ПІСЛЯ слова Python
    # Python 3.14.2 Add to Path → Python Add to Path
    name = re.sub(
        r'^(Python)\s+\d+(\.\d+)*',
        r'\1',
        name,
        flags=re.IGNORECASE
    )

    # 5. Видалення слова "Runtime", "Redistributable", "Additional", "Minimum"
    name = re.sub(r'\b(Runtime|Redistributable|Additional|Minimum)\b',
                  '', name, flags=re.IGNORECASE)

    # 6. Видалення версії (чисел та чисел з крапками) після назви
    name = re.sub(r'[\s-]\d+\.\d+(\.\d+)*\s*$', '', name)

    # 7. Видалення зайвих пробілів
    name = re.sub(r'\s+', ' ', name).strip()

    return name


# ==================== CVE PROCESSING ====================

def extract_english_description(cve_info: Dict) -> str:
    """Витягнення англомовного опису CVE."""
    descriptions = cve_info.get('descriptions', [])
    for description_entry in descriptions:
        if description_entry.get('lang') == 'en':
            return description_entry.get('value', '')
    return ''


def extract_cvss_data(cve_item: Dict) -> Optional[Dict[str, float]]:
    """Витягнення CVSS даних з CVE елемента."""
    metrics = cve_item.get('cve', {}).get('metrics', {})
    for key in ('cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2'):
        metric_list = metrics.get(key)
        if not metric_list:
            continue

        metric = metric_list[0]
        cvss_data = metric.get('cvssData')
        if not cvss_data:
            continue

        score = cvss_data.get('baseScore')
        severity = cvss_data.get('baseSeverity')

        if score is not None:
            return {
                'score': float(score),
                'severity': severity,
            }
    return None


def map_severity(score: float) -> str:
    """Мапінг CVSS балу на рівень серйозності."""
    if score >= CVSS_LIMIT_CRITICAL:
        return 'CRITICAL'
    if score >= CVSS_LIMIT_HIGH:
        return 'HIGH'
    if score >= CVSS_LIMIT_MEDIUM:
        return 'MEDIUM'
    return 'LOW'


def build_result_record(app_name: str,
                        cve_item: Dict,
                        cvss: Dict[str, float]) -> Dict[str, str]:
    """Побудова запису результату з форматуванням Description."""
    cve_info = cve_item.get('cve', {})
    published = cve_item.get('published', '')

    # Витягнення англомовного опису
    description = extract_english_description(cve_info)
    # Форматування: заміна переводів рядка та зайвих пробілів
    description = description.replace(
        '\n', ' ').replace('\r', ' ').replace('\t', ' ')
    description = re.sub(r'\s+', ' ', description).strip()

    return {
        'App': app_name,
        'CVE ID': cve_info.get('id', 'N/A'),
        'Severity': cvss.get('severity') or map_severity(cvss['score']),
        'Score': f"{cvss['score']:.1f}",
        'Description': description,
        'Published': published.split('T')[0],
    }


def process_cve_item(
    app_name: str,
    cve_item: Dict,
) -> Optional[Dict[str, str]]:
    """Обробка CVE елемента для визначення вразливості."""
    cvss = extract_cvss_data(cve_item)
    if not cvss:
        return None

    if cvss['score'] < CVSS_MIN_VULNERABLE:
        return None

    return build_result_record(app_name, cve_item, cvss)


# ==================== NVD API ====================

def fetch_nvd_data(
    session: requests.Session,
    query_params: Dict,
) -> Dict:
    """Витягнення даних з NVD API."""
    response = session.get(
        NVD_API_URL,
        params=query_params,
        timeout=REQUEST_TIMEOUT,
        headers=HEADERS,
    )
    response.raise_for_status()
    return response.json()


def _process_vulnerabilities(
    app_name: str,
    response_data: Dict,
    vulnerable_records: List[Dict[str, str]],
) -> None:
    """Обробка вразливостей з відповіді API."""
    vulnerabilities = response_data.get('vulnerabilities', [])
    for vulnerability in vulnerabilities:
        record = process_cve_item(app_name, vulnerability)
        if record:
            vulnerable_records.append(record)


def _fetch_and_process_vulnerabilities(
    app_name: str,
    session: requests.Session,
    query_params: Dict,
    vulnerable_records: List[Dict[str, str]],
) -> bool:
    """Витягнення та обробка вразливостей."""
    response_data = fetch_nvd_data(session, query_params)
    _process_vulnerabilities(app_name, response_data, vulnerable_records)
    return True


def search_vulnerabilities(
    app_name: str,
    results_per_page: int,
) -> List[Dict[str, str]]:
    """Пошук вразливостей для заданого додатку."""
    vulnerable_records: List[Dict[str, str]] = []
    session = requests.Session()

    query_params = {
        'keywordSearch': app_name,
        'resultsPerPage': max(results_per_page, 1),
    }

    for attempt in range(MAX_RETRIES):
        try:
            _fetch_and_process_vulnerabilities(
                app_name,
                session,
                query_params,
                vulnerable_records,
            )
            break
        except requests.RequestException as error:
            LOGGER.warning(
                'NVD request failed (attempt %d): %s',
                attempt + 1,
                error,
            )
            time.sleep(attempt + 1)

    if not vulnerable_records:
        log_info('  Вразливостей не знайдено')
    else:
        log_info(f'  Знайдено: {len(vulnerable_records)} вразливостей')
    return vulnerable_records


def _search_app_vulnerabilities(
    apps: List[str],
) -> List[Dict[str, str]]:
    """Пошук вразливостей для списку додатків."""
    all_results: List[Dict[str, str]] = []

    for index, app in enumerate(apps, start=1):
        normalized = normalize_app_name(app)
        log_info(
            f'[{index}/{len(apps)}] '
            f'Пошук вразливостей для {normalized} ...',
        )

        all_results.extend(
            search_vulnerabilities(
                normalized,
                results_per_page=RESULTS_PER_PAGE,
            ),
        )

        if index < len(apps):
            log_info(
                f'  Очікування {RATE_LIMIT_DELAY} секунд (rate limit) ...',
            )
            time.sleep(RATE_LIMIT_DELAY)

    return all_results


# ==================== RESULTS ====================

def save_results_csv(vulnerability_records: List[Dict[str, str]]) -> None:
    """Збереження результатів у CSV файл."""
    dataframe = pd.DataFrame(vulnerability_records)
    dataframe.to_csv(CSV_FILENAME, index=False, encoding='utf-8')
    log_info(f'Збережено {len(dataframe)} записів у {CSV_FILENAME}')


def gather_statistics(
        vulnerability_records: Iterable[Dict[str, str]]) -> Dict[str, int]:
    """Збір статистики за рівнями серйозності вразливостей."""
    stats = {
        'CRITICAL': 0,
        'HIGH': 0,
        'MEDIUM': 0,
        'LOW': 0,
    }

    for record in vulnerability_records:
        severity = record.get('Severity', 'LOW')
        stats[severity] += 1

    return stats


# ==================== MAIN ====================

def _log_statistics(stats: Dict[str, int]) -> None:
    """Логування статистики вразливостей."""
    log_section('РЕЗУЛЬТАТИ СКАНУВАННЯ')
    log_info(f'Всього вразливостей: {sum(stats.values())}')
    log_info(f'CRITICAL: {stats["CRITICAL"]}')
    log_info(f'HIGH: {stats["HIGH"]}')
    log_info(f'MEDIUM: {stats["MEDIUM"]}')
    log_info(f'LOW: {stats["LOW"]}')
    log_info(SEPARATOR)


def _log_selected_apps_list(apps: List[str]) -> str:
    """Логування списку вибраних додатків."""
    log_section('ВИБРАНІ ДОДАТКИ ДЛЯ СКАНУВАННЯ')

    for i, app in enumerate(apps, start=1):
        log_info(f'{i:3}. {app}')
    log_info(SEPARATOR)
    return ''


def main() -> None:
    """Головна функція сканера вразливостей."""
    log_section('СКАНЕР ВРАЗЛИВОСТЕЙ')

    run_get_installed_apps()
    apps = sorted(choose_random_apps(read_installed_apps(), APPS_COUNT))
    _log_selected_apps_list(apps)

    all_results = _search_app_vulnerabilities(apps)

    save_results_csv(all_results)
    stats = gather_statistics(all_results)

    _log_statistics(stats)


if __name__ == '__main__':
    main()
